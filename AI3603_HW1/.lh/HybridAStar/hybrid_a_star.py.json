{
    "sourceFile": "HybridAStar/hybrid_a_star.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1695658988274,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1695658988274,
            "name": "Commit-0",
            "content": "import heapq\nimport math\nfrom tqdm import tqdm\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.spatial import cKDTree\nimport sys\nimport pathlib\n\nsys.path.append(str(pathlib.Path(__file__).parent.parent))\n\nfrom dynamic_programming_heuristic import calc_distance_heuristic\nimport reeds_shepp_path_planning as rs\n\nfrom car import *\n\nXY_GRID_RESOLUTION = 1.0  # [m]\nYAW_GRID_RESOLUTION = np.deg2rad(1.0)  # [rad]\nMOTION_RESOLUTION = 0.08  # [m] path interpolate resolution\nN_STEER = 20  # number of steer command\n\nSB_COST = 10.0  # switch back penalty cost\nBACK_COST = 5.0  # backward penalty cost\nSTEER_CHANGE_COST = 15  # steer angle change penalty cost\nSTEER_COST = 0.0  # steer angle not zero cost\nH_COST = 2  # Heuristic cost\n\nshow_animation = True\n\n\nclass Node:\n\n    def __init__(self, x_ind, y_ind, yaw_ind, direction,\n                 x_list, y_list, yaw_list, directions,\n                 steer=0.0, parent_index=None, cost=None):\n        self.x_index = x_ind\n        self.y_index = y_ind\n        self.yaw_index = yaw_ind\n        self.direction = direction\n        self.x_list = x_list\n        self.y_list = y_list\n        self.yaw_list = yaw_list\n        self.directions = directions\n        self.steer = steer\n        self.parent_index = parent_index\n        self.cost = cost\n\n\nclass Path:\n\n    def __init__(self, x_list, y_list, yaw_list, direction_list, cost):\n        self.x_list = x_list\n        self.y_list = y_list\n        self.yaw_list = yaw_list\n        self.direction_list = direction_list\n        self.cost = cost\n\n\nclass Config:\n    \"\"\"\n    Calculate all the space constraints based on the given obstacles.\n    \"\"\"\n\n    def __init__(self, ox, oy, xy_resolution, yaw_resolution):\n        min_x_m = min(ox)\n        min_y_m = min(oy)\n        max_x_m = max(ox)\n        max_y_m = max(oy)\n\n        ox.append(min_x_m)\n        oy.append(min_y_m)\n        ox.append(max_x_m)\n        oy.append(max_y_m)\n\n        self.min_x = round(min_x_m / xy_resolution)\n        self.min_y = round(min_y_m / xy_resolution)\n        self.max_x = round(max_x_m / xy_resolution)\n        self.max_y = round(max_y_m / xy_resolution)\n\n        self.x_w = round(self.max_x - self.min_x)\n        self.y_w = round(self.max_y - self.min_y)\n\n        self.min_yaw = round(- math.pi / yaw_resolution) - 1\n        self.max_yaw = round(math.pi / yaw_resolution)\n        self.yaw_w = round(self.max_yaw - self.min_yaw)\n\n\ndef calc_motion_inputs():\n    for steer in np.concatenate((np.linspace(-MAX_STEER, MAX_STEER,\n                                             N_STEER), [0.0])):\n        for d in [1, -1]:\n            yield [steer, d]\n\n\ndef get_neighbors(current, config, ox, oy, kd_tree):\n    for steer, d in calc_motion_inputs():\n        node = calc_next_node(current, steer, d, config, ox, oy, kd_tree)\n        if node and verify_index(node, config): # check whether is inside the bound\n            yield node\n\n\ndef calc_next_node(current, steer, direction, config, ox, oy, kd_tree):\n    x, y, yaw = current.x_list[-1], current.y_list[-1], current.yaw_list[-1]\n\n    arc_l = XY_GRID_RESOLUTION * 1.5\n    x_list, y_list, yaw_list = [], [], []\n\n    # Simulate about one grid in length.\n    # put all the intermediate points into the list.\n    for _ in np.arange(0, arc_l, MOTION_RESOLUTION):\n        x, y, yaw = move(x, y, yaw, MOTION_RESOLUTION * direction, steer)\n        x_list.append(x)\n        y_list.append(y)\n        yaw_list.append(yaw)\n\n    # Make sure there is no collision along the way, if there is one point that collides, return None.\n    if not check_car_collision(x_list, y_list, yaw_list, ox, oy, kd_tree):\n        return None\n\n    d = direction == 1\n    # Use the last point as the next node.\n    x_ind = round(x / XY_GRID_RESOLUTION)\n    y_ind = round(y / XY_GRID_RESOLUTION)\n    yaw_ind = round(yaw / YAW_GRID_RESOLUTION)\n\n    # x_ind = (x / XY_GRID_RESOLUTION)\n    # y_ind = (y / XY_GRID_RESOLUTION)\n    # yaw_ind = (yaw / YAW_GRID_RESOLUTION)\n\n    # Calculate the cost base on the actions.\n    added_cost = 0.0\n\n    if d != current.direction:\n        added_cost += SB_COST\n\n    # steer penalty\n    added_cost += STEER_COST * abs(steer)\n\n    # steer change penalty\n    added_cost += STEER_CHANGE_COST * abs(current.steer - steer)\n\n    # cost = huristic cost + motion cost + traveled cost\n    cost = current.cost + added_cost + arc_l\n\n    node = Node(x_ind, y_ind, yaw_ind, d, x_list,\n                y_list, yaw_list, [d],\n                parent_index=calc_index(current, config),\n                cost=cost, steer=steer)\n\n    return node\n\n\ndef analytic_expansion(current, goal, ox, oy, kd_tree):\n    start_x = current.x_list[-1]\n    start_y = current.y_list[-1]\n    start_yaw = current.yaw_list[-1]\n\n    goal_x = goal.x_list[-1]\n    goal_y = goal.y_list[-1]\n    goal_yaw = goal.yaw_list[-1]\n\n    max_curvature = math.tan(MAX_STEER) / WB / 1.5\n    paths = rs.calc_paths(start_x, start_y, start_yaw,\n                          goal_x, goal_y, goal_yaw,\n                          max_curvature, step_size=MOTION_RESOLUTION)\n\n    if not paths:\n        return None\n\n    best_path, best = None, None\n\n    for path in paths:\n        if check_car_collision(path.x, path.y, path.yaw, ox, oy, kd_tree):\n            cost = calc_rs_path_cost(path)\n            if not best or best > cost:\n                best = cost\n                best_path = path\n\n    return best_path\n\n\ndef update_node_with_analytic_expansion(current, goal,\n                                        c, ox, oy, kd_tree):\n    '''\n    One shot test from current node to goal node.\n    The path type is chosed from \"Dubins path\" and \"Reeds-Shepp path\"\n    '''\n    path = analytic_expansion(current, goal, ox, oy, kd_tree)\n\n    if path:\n        # if show_animation:\n        #     plt.plot(path.x, path.y, \"--r\")\n        #     plt.pause(1)\n\n        f_x = path.x[1:]\n        f_y = path.y[1:]\n        f_yaw = path.yaw[1:]\n\n        f_cost = current.cost + calc_rs_path_cost(path)\n        f_parent_index = calc_index(current, c)\n\n        fd = []\n        for d in path.directions[1:]:\n            fd.append(d >= 0)\n\n        f_steer = 0.0\n        f_path = Node(current.x_index, current.y_index, current.yaw_index,\n                      current.direction, f_x, f_y, f_yaw, fd,\n                      cost=f_cost, parent_index=f_parent_index, steer=f_steer)\n        return True, f_path\n\n    return False, None\n\n\ndef calc_rs_path_cost(reed_shepp_path):\n    cost = 0.0\n    for length in reed_shepp_path.lengths:\n        if length >= 0:  # forward\n            cost += length\n        else:  # back\n            cost += abs(length) * BACK_COST\n\n    # switch back penalty\n    for i in range(len(reed_shepp_path.lengths) - 1):\n        # switch back\n        if reed_shepp_path.lengths[i] * reed_shepp_path.lengths[i + 1] < 0.0:\n            cost += SB_COST\n\n    # steer penalty\n    for course_type in reed_shepp_path.ctypes:\n        if course_type != \"S\":  # curve\n            cost += STEER_COST * abs(MAX_STEER)\n\n    # ==steer change penalty\n    # calc steer profile\n    n_ctypes = len(reed_shepp_path.ctypes)\n    u_list = [0.0] * n_ctypes\n    for i in range(n_ctypes):\n        if reed_shepp_path.ctypes[i] == \"R\":\n            u_list[i] = - MAX_STEER\n        elif reed_shepp_path.ctypes[i] == \"L\":\n            u_list[i] = MAX_STEER\n\n    for i in range(len(reed_shepp_path.ctypes) - 1):\n        cost += STEER_CHANGE_COST * abs(u_list[i + 1] - u_list[i])\n\n    return cost\n\n\ndef hybrid_a_star_planning(start, goal, ox, oy, xy_resolution, yaw_resolution):\n    \"\"\"\n    start: start node\n    goal: goal node\n    ox: x position list of Obstacles [m]\n    oy: y position list of Obstacles [m]\n    xy_resolution: grid resolution [m]\n    yaw_resolution: yaw angle resolution [rad]\n    \"\"\"\n\n    # normalize angle from [0, 360] to [-180, 180]\n    start[2], goal[2] = rs.pi_2_pi(start[2]), rs.pi_2_pi(goal[2])\n    tox, toy = ox[:], oy[:]\n\n    # This function constructs a new k-dimensional tree object, which is a binary tree data structure useful for nearest neighbor search operations and range queries,\n    # from the array created in the previous step.\n\n    obstacle_kd_tree = cKDTree(np.vstack((tox, toy)).T)\n\n    # get constraints from the obstacles.\n    config = Config(tox, toy, xy_resolution, yaw_resolution)\n\n    # start_node = Node(round(start[0] / xy_resolution),\n    #                   round(start[1] / xy_resolution),\n    #                   round(start[2] / yaw_resolution), True,\n    #                   [start[0]], [start[1]], [start[2]], [True], cost=0)\n    # goal_node = Node(round(goal[0] / xy_resolution),\n    #                  round(goal[1] / xy_resolution),\n    #                  round(goal[2] / yaw_resolution), True,\n    #                  [goal[0]], [goal[1]], [goal[2]], [True])\n    start_node = Node((start[0] / xy_resolution),\n                      (start[1] / xy_resolution),\n                      (start[2] / yaw_resolution), True,\n                      [start[0]], [start[1]], [start[2]], [True], cost=0)\n    goal_node = Node((goal[0] / xy_resolution),\n                     (goal[1] / xy_resolution),\n                     (goal[2] / yaw_resolution), True,\n                     [goal[0]], [goal[1]], [goal[2]], [True])\n\n    # openList and closedList only have the index of the node.\n    # openList stores the frontier nodes of current search.\n    # closedList stores the visited nodes.\n    openList, closedList = {}, {}\n\n    # Calculate all free space L2 distance to goal. (BFS)\n    # Make it a heuristic lookup table.\n\n    # (goal_node.x_list[-1], goal_node.y_list[-1]) = (100, 100)\n    # Bubble_R: circumcircle radius of the car.\n    h_dp, obstacle_extended_map = calc_distance_heuristic(\n        goal_node.x_list[-1], goal_node.y_list[-1],\n        tox, toy, BUBBLE_R)\n\n    extended_obstacle_x = []\n    extended_obstacle_y = []\n    extended_obstacle_set = set()\n    for i in range(len(obstacle_extended_map)):\n        for j in range(len(obstacle_extended_map[0])):\n            if obstacle_extended_map[i][j]:\n                extended_obstacle_x.append(i)\n                extended_obstacle_y.append(j)\n                extended_obstacle_set.add((i,j))\n\n    # h_dp_x = []\n    # h_dp_y = []\n    # h_dp_set = set()\n    # for key in h_dp:\n    #     node  = h_dp[key]\n    #     x = node.x\n    #     y = node.y\n    #     h_dp_x.append(x)\n    #     h_dp_y.append(y)\n    #     h_dp_set.add((x,y))\n    #\n    #\n    # plt.plot(extended_obstacle_x, extended_obstacle_y, \".k\")\n    # plt.grid(True)\n    # plt.axis(\"equal\")\n    # plt.title(\"extended obstacle map\")\n    # plt.show()\n    # plt.close()\n    # plt.plot(h_dp_x, h_dp_y, \".k\")\n    # plt.grid(True)\n    # plt.axis(\"equal\")\n    # plt.title(\"hp\")\n    # plt.show()\n    # plt.close()\n    #\n    # plt.plot(extended_obstacle_x, extended_obstacle_y, \".k\")\n    # plt.plot(h_dp_x, h_dp_y, \".k\",color='red')\n    # plt.grid(True)\n    # plt.axis(\"equal\")\n    # plt.title(\"validate\")\n    # plt.show()\n    # exit(0)\n\n    # pq is a heap queue that stores the cost and index of the node.\n    pq = []\n    openList[calc_index(start_node, config)] = start_node\n    heapq.heappush(pq, (calc_cost(start_node, h_dp, config),\n                        calc_index(start_node, config)))\n    final_path = None\n\n    # Just like the triditional A* search:\n    # - Expand the node with the lowest cost in the openList.\n    # - Add the expanded node to the closedList.\n    # - Add the children of current node to the openList.\n    while True:\n        if not openList:\n            print(\"Error: Cannot find path, No open set\")\n            return [], [], []\n\n        cost, c_id = heapq.heappop(pq)\n        if c_id in openList:\n            current = openList.pop(c_id)\n            closedList[c_id] = current\n        else:\n            continue\n\n        if show_animation:  # pragma: no cover\n            plt.plot(current.x_list[-1], current.y_list[-1], \"xc\")\n            # for stopping simulation with the esc key.\n            plt.gcf().canvas.mpl_connect(\n                'key_release_event',\n                lambda event: [exit(0) if event.key == 'escape' else None])\n            if len(closedList.keys()) % 10 == 0:\n                plt.pause(0.0001)\n\n        extended_ox = []\n        extended_oy = []\n        for i in range(len(obstacle_extended_map)):\n            for j in range(len(obstacle_extended_map[0])):\n                if obstacle_extended_map[i][j]:\n                    extended_ox.append(i)\n                    extended_oy.append(j)\n\n        obstacle_extended_kd_tree = cKDTree(np.vstack((extended_ox, extended_oy)).T)\n        is_updated, final_path = update_node_with_analytic_expansion(\n            current, goal_node, config, ox, oy, obstacle_kd_tree)\n        # is_updated, final_path = update_node_with_analytic_expansion(\n        #     current, goal_node, config, extended_ox, extended_oy, obstacle_extended_kd_tree)\n\n        # If we get one shot path, we can stop searching and return the path.\n        if is_updated:\n            print(\"path found\")\n            break\n\n        # expand the node with vehicle kinamatics model.\n        for neighbor in get_neighbors(current, config, extended_ox, extended_oy,\n                                      kd_tree=obstacle_extended_kd_tree):\n            neighbor_index = calc_index(neighbor, config)\n            if neighbor_index in closedList:\n                continue\n            if neighbor not in openList \\\n                    or openList[neighbor_index].cost > neighbor.cost:\n                heapq.heappush(\n                    pq, (calc_cost(neighbor, h_dp, config),\n                         neighbor_index))\n                openList[neighbor_index] = neighbor\n\n    path = get_final_path(closedList, final_path)\n    return path,extended_ox,extended_oy\n\n\ndef calc_cost(n, h_dp, c):\n    '''\n    calculate the distance heuristic cost of a each based on the lookup table h_dp.\n    '''\n    ind = (n.y_index - c.min_y) * c.x_w + (n.x_index - c.min_x)\n    if ind not in h_dp:\n        return n.cost + np.infty  # collision cost\n    return n.cost + H_COST * h_dp[ind].cost\n\n\ndef get_final_path(closed, goal_node):\n    reversed_x, reversed_y, reversed_yaw = \\\n        list(reversed(goal_node.x_list)), list(reversed(goal_node.y_list)), \\\n            list(reversed(goal_node.yaw_list))\n    direction = list(reversed(goal_node.directions))\n    nid = goal_node.parent_index\n    final_cost = goal_node.cost\n\n    while nid:\n        n = closed[nid]\n        reversed_x.extend(list(reversed(n.x_list)))\n        reversed_y.extend(list(reversed(n.y_list)))\n        reversed_yaw.extend(list(reversed(n.yaw_list)))\n        direction.extend(list(reversed(n.directions)))\n\n        nid = n.parent_index\n\n    reversed_x = list(reversed(reversed_x))\n    reversed_y = list(reversed(reversed_y))\n    reversed_yaw = list(reversed(reversed_yaw))\n    direction = list(reversed(direction))\n\n    # adjust first direction\n    direction[0] = direction[1]\n\n    path = Path(reversed_x, reversed_y, reversed_yaw, direction, final_cost)\n\n    return path\n\n\ndef verify_index(node, c):\n    x_ind, y_ind = node.x_index, node.y_index\n    if c.min_x <= x_ind <= c.max_x and c.min_y <= y_ind <= c.max_y:\n        return True\n\n    return False\n\n\ndef calc_index(node, c):\n    '''\n    Map the node to a 1D array.\n    '''\n    ind = (node.yaw_index - c.min_yaw) * c.x_w * c.y_w + \\\n          (node.y_index - c.min_y) * c.x_w + (node.x_index - c.min_x)\n\n    if ind <= 0:\n        print(\"Error(calc_index):\", ind)\n\n    return ind\n\n\ndef main():\n    print(\"Start Hybrid A* planning\")\n    # load map\n    map = np.load(\"/Users/husky/Three-Year-Aut/AI-theory/AI3603_HW1/3-map/map.npy\")\n    ox, oy = [], []\n\n    # load obstacles\n    for i in range(map.shape[0]):\n        for j in range(map.shape[1]):\n            if map[i][j] == 1:\n                ox.append(i)\n                oy.append(j)\n\n    # Define start position of the car point.\n    start = [10.0, 10.0, np.deg2rad(70.0)]\n    goal = [100.0, 100.0, np.deg2rad(0.0)]\n\n    print(\"start : \", start)\n    print(\"goal : \", goal)\n\n    if show_animation:\n        plt.plot(ox, oy, \".k\")\n        rs.plot_arrow(start[0], start[1], start[2], fc='g')\n        rs.plot_arrow(goal[0], goal[1], goal[2])\n\n        plt.grid(True)\n        plt.axis(\"equal\")\n\n    path,exox,exoy = hybrid_a_star_planning(\n        start, goal, ox, oy, XY_GRID_RESOLUTION, YAW_GRID_RESOLUTION)\n\n    x = path.x_list\n    y = path.y_list\n    yaw = path.yaw_list\n\n    if show_animation:\n        for i_x, i_y, i_yaw in zip(x, y, yaw):\n            plt.cla()\n            plt.plot(ox, oy, \".k\")\n            plt.plot(x, y, \"-r\", label=\"Hybrid A* path\")\n            plt.title(\"Hybrid A*\")\n            plt.grid(True)\n            plt.axis(\"equal\")\n            plot_car(i_x, i_y, i_yaw)\n            plt.pause(1e-6)\n    else:\n        plt.cla()  # clear current subplot\n        plt.plot(exox, exoy, \".k\")\n        plt.plot(start[0], start[1], \"xr\")\n        plt.plot(goal[0], goal[1], \"xb\")\n        plt.plot(x, y, \"-r\", label=\"Hybrid A* path\")\n        plt.grid(True)\n        plt.axis(\"equal\")\n        plt.show()\n        plt.close()\n        plt.cla()  # clear current subplot\n        plt.plot(ox, oy, \".k\")\n        plt.plot(start[0], start[1], \"xr\")\n        plt.plot(goal[0], goal[1], \"xb\")\n        plt.plot(x, y, \"-r\", label=\"Hybrid A* path\")\n        plt.grid(True)\n        plt.axis(\"equal\")\n        plt.show()\n        plt.close()\n\n\n    print(__file__ + \" done!!\")\n\n\nif __name__ == '__main__':\n    main()\n"
        }
    ]
}